import json
import asyncio
from typing import List, Dict, Optional
import google.generativeai as genai
from app.core.config import settings
from app.schemas.nowwhat import IntentOption
from app.schemas.questions import Question, Option
from app.services.prompt_loader import prompt_loader
import logging
import uuid

logger = logging.getLogger(__name__)
# Gemini ì„œë¹„ìŠ¤ ë””ë²„ê¹…ì„ ìœ„í•´ ì„ì‹œë¡œ DEBUG ë ˆë²¨ ì„¤ì •
logger.setLevel(logging.DEBUG)
# ì½˜ì†” í•¸ë“¤ëŸ¬ ì¶”ê°€ (ì´ë¯¸ ìˆë‹¤ë©´ ë¬´ì‹œë¨)
if not logger.handlers:
    console_handler = logging.StreamHandler()
    console_handler.setLevel(logging.DEBUG)
    formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
    console_handler.setFormatter(formatter)
    logger.addHandler(console_handler)

# Gemini API ì„¤ì •
if settings.GEMINI_API_KEY:
    genai.configure(api_key=settings.GEMINI_API_KEY)
    logger.info(f"Gemini API configured with key: {settings.GEMINI_API_KEY[:10]}...{settings.GEMINI_API_KEY[-4:]}")
else:
    logger.error("GEMINI_API_KEY not found in settings")

class GeminiService:
    def __init__(self):
        if not settings.GEMINI_API_KEY:
            logger.error("Cannot initialize GeminiService: GEMINI_API_KEY not set")
            raise ValueError("GEMINI_API_KEY not configured")
        
        self.model = genai.GenerativeModel(settings.GEMINI_MODEL)
        logger.info(f"GeminiService initialized with model: {settings.GEMINI_MODEL}")
        
    async def analyze_intent(self, goal: str, user_country: Optional[str] = None) -> List[IntentOption]:
        """ì‚¬ìš©ì ëª©í‘œë¥¼ ë¶„ì„í•˜ì—¬ 4ê°€ì§€ ì˜ë„ ì˜µì…˜ ìƒì„±"""
        try:
            prompt = self._create_prompt(goal, user_country)
            
            # 3íšŒ ì¬ì‹œë„ ë¡œì§
            for attempt in range(3):
                try:
                    response = await self._call_gemini_api(prompt)
                    intents = self._parse_response(response)
                    
                    if len(intents) == 4:
                        return intents
                    else:
                        logger.warning(f"Gemini returned {len(intents)} intents instead of 4 (attempt {attempt + 1})")
                        
                except Exception as e:
                    logger.error(f"Gemini API call failed (attempt {attempt + 1}): {str(e)}")
                    if attempt < 2:  # ë§ˆì§€ë§‰ ì‹œë„ê°€ ì•„ë‹ˆë©´ ì§€ì—° í›„ ì¬ì‹œë„
                        await asyncio.sleep(2 ** attempt)  # exponential backoff
                    
            # ëª¨ë“  ì¬ì‹œë„ ì‹¤íŒ¨ì‹œ ê¸°ë³¸ í…œí”Œë¦¿ ë°˜í™˜
            logger.warning("All Gemini API attempts failed, using default template")
            return self._get_default_template()
            
        except Exception as e:
            logger.error(f"Intent analysis failed: {str(e)}")
            return self._get_default_template()

    async def generate_questions(
        self, 
        goal: str, 
        intent_title: str, 
        user_country: Optional[str] = None
    ) -> List[Question]:
        """ì„ íƒëœ ì˜ë„ì— ë”°ë¥¸ ë§ì¶¤ ì§ˆë¬¸ ìƒì„± (3-5ê°œ)"""
        try:
            prompt = self._create_questions_prompt(goal, intent_title, user_country)
            
            # 3íšŒ ì¬ì‹œë„ ë¡œì§
            for attempt in range(3):
                try:
                    response = await self._call_gemini_api(prompt)
                    questions = self._parse_questions_response(response)
                    
                    if 3 <= len(questions) <= 5:
                        return questions
                    else:
                        logger.warning(f"Gemini returned {len(questions)} questions instead of 3-5 (attempt {attempt + 1})")
                        
                except Exception as e:
                    logger.error(f"Gemini questions API call failed (attempt {attempt + 1}): {str(e)}")
                    if attempt < 2:
                        await asyncio.sleep(2 ** attempt)
                    
            # ëª¨ë“  ì¬ì‹œë„ ì‹¤íŒ¨ì‹œ ìºì‹œëœ ì§ˆë¬¸ í…œí”Œë¦¿ ë°˜í™˜
            logger.warning("All Gemini questions API attempts failed, using cached template")
            return self._get_cached_questions_template(intent_title)
            
        except Exception as e:
            logger.error(f"Question generation failed: {str(e)}")
            return self._get_cached_questions_template(intent_title)

    def _create_questions_prompt(self, goal: str, intent_title: str, user_country: Optional[str] = None) -> str:
        """ì§ˆë¬¸ ìƒì„±ìš© í”„ë¡¬í”„íŠ¸ ìƒì„±"""
        country_context = self._get_country_context(user_country)
        
        return prompt_loader.get_questions_generation_prompt(
            goal=goal,
            intent_title=intent_title,
            user_country=user_country,
            country_context=country_context
        )

    def _get_country_context(self, user_country: Optional[str]) -> str:
        """êµ­ê°€ë³„ ë§ì¶¤ ì»¨í…ìŠ¤íŠ¸"""
        contexts = {
            "KR": "í•œêµ­ ê±°ì£¼ì ê¸°ì¤€, í•œêµ­ ë¬¸í™”ì™€ í™˜ê²½ ê³ ë ¤",
            "US": "ë¯¸êµ­ ê±°ì£¼ì ê¸°ì¤€, ë¯¸êµ­ ë¬¸í™”ì™€ í™˜ê²½ ê³ ë ¤", 
            "JP": "ì¼ë³¸ ê±°ì£¼ì ê¸°ì¤€, ì¼ë³¸ ë¬¸í™”ì™€ í™˜ê²½ ê³ ë ¤",
            "CN": "ì¤‘êµ­ ê±°ì£¼ì ê¸°ì¤€, ì¤‘êµ­ ë¬¸í™”ì™€ í™˜ê²½ ê³ ë ¤"
        }
        return contexts.get(user_country, "ê¸€ë¡œë²Œ ê¸°ì¤€")

    def _parse_questions_response(self, response: str) -> List[Question]:
        """Gemini ì§ˆë¬¸ ì‘ë‹µ íŒŒì‹±"""
        try:
            # ì‘ë‹µì´ ë¹„ì–´ìˆëŠ”ì§€ í™•ì¸
            if not response or not response.strip():
                logger.warning("Gemini returned empty response")
                raise ValueError("Empty response from Gemini")
            
            # JSON ë¶€ë¶„ë§Œ ì¶”ì¶œ
            response = response.strip()
            logger.debug(f"Raw Gemini response: {response[:200]}...")  # ë””ë²„ê¹…ìš©
            
            if response.startswith("```json"):
                response = response[7:]
            if response.endswith("```"):
                response = response[:-3]
            response = response.strip()
            
            # ë¹ˆ ì‘ë‹µ ì¬í™•ì¸
            if not response:
                logger.warning("Response became empty after cleaning")
                raise ValueError("Empty response after cleaning")
            
            questions_data = json.loads(response)
            
            if not isinstance(questions_data, list):
                raise ValueError("Response is not a list")
                
            questions = []
            for item in questions_data:
                # í•„ìˆ˜ í•„ë“œ í™•ì¸
                if not all(key in item for key in ["id", "text", "type", "required"]):
                    raise ValueError("Missing required fields in question")
                
                # options ì²˜ë¦¬
                options = None
                if item["type"] == "multiple" and "options" in item:
                    options = [
                        Option(
                            id=opt["id"],
                            text=opt["text"], 
                            value=opt["value"]
                        ) for opt in item["options"]
                    ]
                
                questions.append(Question(
                    id=item["id"],
                    text=item["text"],
                    type=item["type"],
                    options=options,
                    required=item["required"]
                ))
                
            return questions
            
        except json.JSONDecodeError as e:
            logger.error(f"JSON decode error: {str(e)}, Response: '{response[:500]}'")
            raise Exception(f"Failed to parse Gemini questions response: Invalid JSON - {str(e)}")
        except Exception as e:
            logger.error(f"Questions parsing error: {str(e)}, Response: '{response[:500] if 'response' in locals() else 'N/A'}'")
            raise Exception(f"Failed to parse Gemini questions response: {str(e)}")

    def _get_cached_questions_template(self, intent_title: str) -> List[Question]:
        """ì˜ë„ë³„ ìºì‹œëœ ì§ˆë¬¸ í…œí”Œë¦¿"""
        templates = {
            "ì—¬í–‰ ê³„íš": [
                Question(
                    id="q_duration",
                    text="ì—¬í–‰ ê¸°ê°„ì€ ì–¼ë§ˆë‚˜ ë˜ë‚˜ìš”?",
                    type="multiple",
                    options=[
                        Option(id="opt_3days", text="2ë°• 3ì¼", value="3days"),
                        Option(id="opt_5days", text="4ë°• 5ì¼", value="5days"),
                        Option(id="opt_1week", text="1ì£¼ì¼", value="1week"),
                        Option(id="opt_longer", text="1ì£¼ì¼ ì´ìƒ", value="longer")
                    ],
                    required=True
                ),
                Question(
                    id="q_companions",
                    text="ëˆ„êµ¬ì™€ í•¨ê»˜ ê°€ì‹œë‚˜ìš”?",
                    type="multiple",
                    options=[
                        Option(id="opt_alone", text="í˜¼ì", value="alone"),
                        Option(id="opt_couple", text="ì—°ì¸/ë°°ìš°ìì™€", value="couple"),
                        Option(id="opt_family", text="ê°€ì¡±ê³¼", value="family"),
                        Option(id="opt_friends", text="ì¹œêµ¬ë“¤ê³¼", value="friends")
                    ],
                    required=True
                ),
                Question(
                    id="q_activities",
                    text="ì£¼ë¡œ í•˜ê³  ì‹¶ì€ í™œë™ì€ ë¬´ì—‡ì¸ê°€ìš”?",
                    type="multiple",
                    options=[
                        Option(id="opt_sightseeing", text="ê´€ê´‘/ëª…ì†Œ íƒë°©", value="sightseeing"),
                        Option(id="opt_food", text="ë§›ì§‘ íƒë°©", value="food"),
                        Option(id="opt_shopping", text="ì‡¼í•‘", value="shopping"),
                        Option(id="opt_culture", text="ë¬¸í™” ì²´í—˜", value="culture")
                    ],
                    required=True
                )
            ],
            "ê³„íš ì„¸ìš°ê¸°": [
                Question(
                    id="q_timeline",
                    text="ì–¸ì œê¹Œì§€ ê³„íšì„ ì™„ì„±í•˜ê³  ì‹¶ìœ¼ì‹ ê°€ìš”?",
                    type="multiple",
                    options=[
                        Option(id="opt_1week", text="1ì£¼ì¼ ë‚´", value="1week"),
                        Option(id="opt_1month", text="1ë‹¬ ë‚´", value="1month"),
                        Option(id="opt_3months", text="3ë‹¬ ë‚´", value="3months"),
                        Option(id="opt_flexible", text="ìœ ì—°í•˜ê²Œ", value="flexible")
                    ],
                    required=True
                ),
                Question(
                    id="q_priority",
                    text="ê°€ì¥ ì¤‘ìš”í•˜ê²Œ ìƒê°í•˜ëŠ” ê²ƒì€?",
                    type="multiple",
                    options=[
                        Option(id="opt_time", text="ì‹œê°„ íš¨ìœ¨ì„±", value="time"),
                        Option(id="opt_cost", text="ë¹„ìš© ì ˆì•½", value="cost"),
                        Option(id="opt_quality", text="í’ˆì§ˆ/ë§Œì¡±ë„", value="quality"),
                        Option(id="opt_convenience", text="í¸ì˜ì„±", value="convenience")
                    ],
                    required=True
                )
            ]
        }
        
        return templates.get(intent_title, self._get_default_questions_template())

    def _get_default_questions_template(self) -> List[Question]:
        """ê¸°ë³¸ ì§ˆë¬¸ í…œí”Œë¦¿"""
        return [
            Question(
                id="q_when",
                text="ì–¸ì œê¹Œì§€ ì´ ëª©í‘œë¥¼ ë‹¬ì„±í•˜ê³  ì‹¶ìœ¼ì‹ ê°€ìš”?",
                type="multiple",
                options=[
                    Option(id="opt_1week", text="1ì£¼ì¼ ë‚´", value="1week"),
                    Option(id="opt_1month", text="1ë‹¬ ë‚´", value="1month"),
                    Option(id="opt_3months", text="3ë‹¬ ë‚´", value="3months"),
                    Option(id="opt_6months", text="6ë‹¬ ë‚´", value="6months")
                ],
                required=True
            ),
            Question(
                id="q_resources",
                text="ì´ ëª©í‘œë¥¼ ìœ„í•´ íˆ¬ìí•  ìˆ˜ ìˆëŠ” ìì›ì€?",
                type="multiple", 
                options=[
                    Option(id="opt_time", text="ì£¼ë¡œ ì‹œê°„", value="time"),
                    Option(id="opt_money", text="ì£¼ë¡œ ëˆ", value="money"),
                    Option(id="opt_both", text="ì‹œê°„ê³¼ ëˆ ëª¨ë‘", value="both"),
                    Option(id="opt_minimal", text="ìµœì†Œí•œë§Œ", value="minimal")
                ],
                required=True
            ),
            Question(
                id="q_priority",
                text="ê°€ì¥ ì¤‘ìš”í•˜ê²Œ ìƒê°í•˜ëŠ” ê²ƒì€?",
                type="multiple",
                options=[
                    Option(id="opt_speed", text="ë¹ ë¥¸ ë‹¬ì„±", value="speed"),
                    Option(id="opt_quality", text="ë†’ì€ í’ˆì§ˆ", value="quality"),
                    Option(id="opt_cost", text="ë¹„ìš© ì ˆì•½", value="cost"),
                    Option(id="opt_balance", text="ê· í˜•ì¡íŒ ì ‘ê·¼", value="balance")
                ],
                required=True
            )
        ]
    
    def _create_prompt(self, goal: str, user_country: Optional[str] = None) -> str:
        """Gemini APIìš© í”„ë¡¬í”„íŠ¸ ìƒì„±"""
        return prompt_loader.get_intent_analysis_prompt(goal, user_country)

    async def _call_gemini_api(self, prompt: str) -> str:
        """Gemini API í˜¸ì¶œ"""
        try:
            logger.debug(f"Sending prompt to Gemini (length: {len(prompt)} chars)")
            response = await asyncio.to_thread(
                self.model.generate_content, 
                prompt,
                generation_config=genai.types.GenerationConfig(
                    max_output_tokens=4096,  # ë” í° ì¦ê°€
                    temperature=0.7,
                    top_p=0.8,
                    top_k=40
                )
            )
            
            # ì‘ë‹µ ìƒíƒœ í™•ì¸
            if not response:
                logger.error("Gemini returned None response")
                raise Exception("Gemini returned None response")
            
            # ì‘ë‹µ ê°ì²´ êµ¬ì¡° í™•ì¸
            logger.debug(f"Gemini response type: {type(response)}")
            logger.debug(f"Gemini response attributes: {dir(response)}")
            
            # Safety rating ë° finish reason í™•ì¸
            if hasattr(response, 'candidates') and response.candidates:
                for i, candidate in enumerate(response.candidates):
                    finish_reason = candidate.finish_reason if hasattr(candidate, 'finish_reason') else 'N/A'
                    logger.debug(f"Candidate {i} finish_reason: {finish_reason}")
                    
                    # finish_reason í•´ì„
                    if finish_reason == 2:
                        logger.warning("Response was truncated due to MAX_TOKENS limit - consider increasing max_output_tokens")
                    elif finish_reason == 3:
                        logger.warning("Response was blocked by safety filters")
                    elif finish_reason == 4:
                        logger.warning("Response was blocked due to recitation concerns")
                    
                    if hasattr(candidate, 'safety_ratings'):
                        logger.debug(f"Candidate {i} safety_ratings: {candidate.safety_ratings}")
            
            if not hasattr(response, 'text'):
                logger.error(f"Gemini response has no text attribute: {type(response)}")
                # ëŒ€ì•ˆìœ¼ë¡œ candidatesì—ì„œ í…ìŠ¤íŠ¸ ì¶”ì¶œ ì‹œë„
                if hasattr(response, 'candidates') and response.candidates:
                    for candidate in response.candidates:
                        if hasattr(candidate, 'content') and hasattr(candidate.content, 'parts'):
                            for part in candidate.content.parts:
                                if hasattr(part, 'text') and part.text:
                                    logger.debug(f"Found text in candidate.content.parts: {part.text[:100]}...")
                                    response_text = part.text
                                    break
                    else:
                        raise Exception("Gemini response has no text attribute and no text in candidates")
                else:
                    raise Exception("Gemini response has no text attribute")
            else:
                response_text = response.text
            
            logger.debug(f"Raw Gemini response (length: {len(response_text) if response_text else 0}): '{response_text}'")
            
            if not response_text or not response_text.strip():
                logger.error("Gemini returned empty or whitespace-only response")
                raise Exception("Gemini returned empty response")
                
            return response_text
            
        except Exception as e:
            logger.error(f"Gemini API call error details: {str(e)}")
            raise Exception(f"Gemini API call failed: {str(e)}")
    
    def _parse_response(self, response: str) -> List[IntentOption]:
        """Gemini ì‘ë‹µ íŒŒì‹±"""
        try:
            logger.debug(f"Intent parsing - Raw response: '{response[:200]}...' (total length: {len(response)})")
            
            # JSON ë¶€ë¶„ë§Œ ì¶”ì¶œ (ë§ˆí¬ë‹¤ìš´ ì½”ë“œ ë¸”ë¡ ì œê±°)
            response = response.strip()
            logger.debug(f"Intent parsing - After strip: '{response[:200]}...'")
            
            if response.startswith("```json"):
                response = response[7:]
                logger.debug("Intent parsing - Removed ```json prefix")
            if response.endswith("```"):
                response = response[:-3]
                logger.debug("Intent parsing - Removed ``` suffix")
            response = response.strip()
            
            logger.debug(f"Intent parsing - Final JSON to parse: '{response[:200]}...'")
            
            if not response:
                logger.error("Intent parsing - Response became empty after cleaning")
                raise ValueError("Empty response after cleaning")
            
            intents_data = json.loads(response)
            logger.debug(f"Intent parsing - Successfully parsed JSON with {len(intents_data) if isinstance(intents_data, list) else 'non-list'} items")
            
            if not isinstance(intents_data, list):
                raise ValueError("Response is not a list")
                
            intents = []
            for item in intents_data:
                if not all(key in item for key in ["title", "description", "icon"]):
                    raise ValueError("Missing required fields in intent")
                    
                intents.append(IntentOption(
                    title=item["title"],
                    description=item["description"],
                    icon=item["icon"]
                ))
                
            return intents
            
        except Exception as e:
            raise Exception(f"Failed to parse Gemini response: {str(e)}")
    
    def _get_default_template(self) -> List[IntentOption]:
        """ê¸°ë³¸ ì˜ë„ í…œí”Œë¦¿"""
        return [
            IntentOption(
                title="ê³„íš ì„¸ìš°ê¸°",
                description="ëª©í‘œë¥¼ ë‹¬ì„±í•˜ê¸° ìœ„í•œ êµ¬ì²´ì ì¸ ê³„íšì„ ì„¸ìš°ê³  ì‹¶ìœ¼ì‹ ê°€ìš”?",
                icon="ğŸ“‹"
            ),
            IntentOption(
                title="ì¤€ë¹„í•˜ê¸°",
                description="í•„ìš”í•œ ê²ƒë“¤ì„ ì¤€ë¹„í•˜ê³  ì²´í¬ë¦¬ìŠ¤íŠ¸ë¥¼ ë§Œë“¤ê³  ì‹¶ìœ¼ì‹ ê°€ìš”?",
                icon="âœ…"
            ),
            IntentOption(
                title="ì •ë³´ ì°¾ê¸°",
                description="ê´€ë ¨ëœ ì •ë³´ë¥¼ ì¡°ì‚¬í•˜ê³  ì•Œì•„ë³´ê³  ì‹¶ìœ¼ì‹ ê°€ìš”?",
                icon="ğŸ”"
            ),
            IntentOption(
                title="ë°”ë¡œ ì‹œì‘í•˜ê¸°",
                description="ì§€ê¸ˆ ë‹¹ì¥ ì‹¤í–‰í•  ìˆ˜ ìˆëŠ” ë°©ë²•ì„ ì•Œê³  ì‹¶ìœ¼ì‹ ê°€ìš”?",
                icon="ğŸš€"
            )
        ]

# ì„œë¹„ìŠ¤ ì¸ìŠ¤í„´ìŠ¤
gemini_service = GeminiService() 